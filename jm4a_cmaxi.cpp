#include "Arduino.h" 
#include "jm4a_cmaxi.h" 
#include <avr/interrupt.h> 
#include "jm4a_01.h" 
#include"jm4a_02.h" 
#include "jm4a_03.h" 
#include <stdlib.h> 
uint8_t F01[12] = {54,55,56,57,58,59,60,61,62,63,18,19}; uint8_t F02[22] = {2,3,4,5,6,7,8,9,10,11,12,13,22,23,24,25,26,27,28,29,30,31}; uint8_t F03[10] = {10,10,10,10,10,10,10,10,10,10}; bool F04[10] = {0,0,0,0,0,0,0,0,0,0}; bool F05[12] ={0,0,0,0,0,0,0,0,0,0,0,0}; bool F06[12] = {0,0,0,0,0,0,0,0,0,0,0,0}; bool F07[4] = {0,0,0,0}; volatile int F08[12] = {0,0,0,0,0,0,0,0,0,0,0,0}; volatile int F09[12] = {0,0,0,0,0,0,0,0,0,0,0,0}; volatile int F10[22] =  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; volatile int F11[22]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; volatile char F12[2] = {'a','z'}; volatile char F13[2] = {'z','a'}; volatile uint8_t F14 = 0; volatile bool F15 = false; bool F16 = false; bool F17 = false; bool F18 = false; volatile uint32_t F19[3] = {0,0,0}; volatile uint16_t F20[3] = {0,0,0}; char F21 = 'A'; const char* F22 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; jm4a_cmaxi::jm4a_cmaxi() { } void jm4a_cmaxi::begin(unsigned long f) { F70.F62(f); F91(0); F91(20);for (uint8_t i = 0; i < 8; i++) { F54.F49(F01[i],0); } for (uint8_t i = 0; i < 22; i++) { F54.F49(F02[i],1); } } void jm4a_cmaxi::dataTransfer() { if (F17 == false) { F23(); } if (F16 == false) { F27(); } } void jm4a_cmaxi::F23() { if (F70.F68()) { char f[80]; uint8_t ff =F70.F67('\n', f, sizeof(f) - 1); while (F70.F68()) { F70.F66();  } if(f[0] != F21 || f[ff - 1] != ';'){ F91(1); return;       } if (f[1] == '>') { F24(f,ff); return; } if (f[1] == '*') { F33(f,ff); return; } } } void jm4a_cmaxi::F24(char* f, uint8_t ff){ if (ff == 28) { for (uint8_t i = 2; i < 24; i++) { F11[i - 2] = f[i] - '0'; } F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; } else if (ff > 28) { uint8_t k = 0; for (uint8_t i = 2; i < ff; i++) { if (f[i] == ':') {                   break; } else if (f[i] == '.') { continue; } else if (f[i] == ',') { if (f[i + 2] == ',' || f[i + 2] == '.') { F11[k] = f[i + 1] - '0'; i = i + 1; } else if (f[i + 3] == ',' || f[i + 3] == '.') { F11[k] = ((f[i + 1] - '0') *10) + f[i + 2] - '0'; i = i + 2; } else if (f[i + 4] == ',' || f[i + 4] == '.') { F11[k] = ((f[i + 1] - '0') *100) + ((f[i + 2] - '0') *10) + f[i + 3] - '0'; i = i + 3; } else if (f[i + 5] == ',' || f[i + 5] == '.') { F11[k] = ((f[i + 1] - '0') *1000) + ((f[i + 2] - '0') *100) + ((f[i + 3] - '0') *10) + f[i + 4] - '0'; i = i + 4; } } else { F11[k] = f[i] - '0'; } k++; if(k>22){ F91(2); return; } } F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; } else{ F91(3); return; } F25(F11,22); if (F13[1] == F12[1] && F13[0] == F12[0]) { F26(); } else { F91(4); } } void jm4a_cmaxi::F25(int* f, uint8_t ff) { F14 = 0; uint8_t fff = 0x00; for ( uint8_t i = 0; i < ff; i++) { fff ^= f[i]; for (uint8_t j = 0; j < 8; j++) { if (fff & 0x80) fff = (fff << 1) ^ 0x07; else fff <<= 1; } } F14 = fff; uint8_t a = F14 / 62; uint8_t b  = F14 % 62; F13[1] = F22[a]; F13[0] = F22[b];  } void jm4a_cmaxi::F26(){ memcpy(F10, F11, sizeof(F11)); for(uint8_t i =0; i<12; i++){ if (!F05[i]) { F30(i); } else { if(!F06[i]){ F55(i); } } } for(uint8_t i =12; i<22; i++){ F30(i); } if (F18) { F32("="); } } void jm4a_cmaxi::F27() { F15 = false; for (uint8_t i = 0; i < 10; i++) { if (!F04[i]) { F28(i); } else { F29(i); } } for (uint8_t i = 10; i < 12; i++) { F28(i); } if (F15 == true) { F31(); } } void jm4a_cmaxi::F28(uint8_t f){ F08[f] = F54.F50(F01[f]); if (F09[f] != F08[f]) { F09[f] = F08[f]; F15 = true; } } void jm4a_cmaxi::F29(uint8_t f){ F08[f] = F54.F52(F01[f]); if (F09[f] + F03[f] <= F08[f] || F09[f] - F03[f] >= F08[f]) { F09[f] = F08[f]; F15 = true; } } void jm4a_cmaxi::F30(uint8_t f){ F54.F51(F02[f], F10[f]); } void jm4a_cmaxi::F55(uint8_t f){ F54.F53(F02[f], F10[f]); } void jm4a_cmaxi::F31(){ F25(F08,12); F56 f = ""; f.F57(">"); for (uint8_t i = 0; i < 10; i++) { if (!F04[i]) { f.F57(F08[i]); } else { if (i == 0) { f.F57(","); } else if (!F04[i - 1]) { f.F57(","); } if (i == 9) { f.F57(F08[i]); f.F57("."); break; } f.F57(F08[i]); if (F04[i + 1]) { f.F57(","); } else { f.F57("."); } } } for (uint8_t i = 10; i < 12; i++) { f.F57(F08[i]); } f.F57(":"); f.F57(F13[1]); f.F57(F13[0]); F32(f.F59()); } void jm4a_cmaxi::F32(F56 f){ F56 ff = ""; ff.F57(F21); ff.F57(f); ff.F57(";"); F70.F65(ff.F59()); F70.F69(); } void jm4a_cmaxi::F33(char* f, uint8_t ff){ if(f[2]=='P'){ if(f[3]=='F'){ F39(f,ff); return; }else if(f[3]=='D'){ F34(f,ff); return; }else{ F91(5); return; } }else{ F91(5); return; } } void jm4a_cmaxi::F34(char* f, uint8_t ff){ float fff; uint8_t k = 0; uint8_t r = 7; uint8_t rr; if(f[6]=='/'){ rr = ((f[4]- '0') *10)+f[5]-'0'; if(rr <0  || rr>11){ F91(6); return; } }else{ F91(2); return; } for(uint8_t i = 7; i<ff; i++){ if(f[i+1]==':'){ k=i; break; } } char kk[(k-r)+2]; for(uint8_t i=0; i<(k-r)+1; i++){ kk[i]=f[r+i]; } kk[(k-r)+1] = '\0'; fff = atof(kk); int rrr = floor(fff); int kkk[1] = { static_cast<int>(rrr) }; F25(kkk,1); F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; if (F13[1] == F12[1] && F13[0] == F12[0]){ F38(rr,fff); }else{ F91(4); } } void jm4a_cmaxi::F35() { F91(7); } void jm4a_cmaxi::F36(uint8_t f, float ff) { if(f==2 && F06[2]){ if(ff<0.1){ if(F07[0]==true){ TCCR0A &= ~((1 << COM0B1) | (1 << COM0B0)); F07[0]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[0]==true) { TCCR0A &= ~((1 << COM0B1) | (1 << COM0B0));  F07[0] = false; } F10[f]=1; F30(f);   }else{ if(F07[0]==false){ TCCR0A |= (1 << COM0B1); TCCR0A &= ~(1 << COM0B0); F07[0]=true; } OCR0B = (uint8_t)((ff / 100.0) * 255); } } else if(f==11 && F06[11]){ if(ff<0.1){ if(F07[1]==true){ TCCR0A &= ~((1 << COM0A1) | (1 << COM0A0));  F07[1]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[1]==true) { TCCR0A &= ~((1 << COM0A1) | (1 << COM0A0)); F07[1] = false; } F10[f]=1; F30(f);   }else{ if(F07[1]==false){ TCCR0A |= (1 << COM0A1); TCCR0A &= ~(1 << COM0A0); F07[1]=true; } OCR0A = (uint8_t)((ff / 100.0) * 255); } }else if(f==7 && F06[7]){ if(ff<0.1){ if(F07[2]==true){ TCCR2A &= ~((1 << COM2B1) | (1 << COM2B0));   F07[2]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[2]==true) { TCCR2A &= ~((1 << COM2B1) | (1 << COM2B0));  F07[2] = false; } F10[f]=1; F30(f);   }else{ if(F07[2]==false){ TCCR2A |= (1 << COM2B1); TCCR2A &= ~(1 << COM2B0); F07[2]=true; } OCR2B = (uint8_t)((ff / 100.0) * 255); } } else if(f==8 && F06[8]){ if(ff<0.1){ if(F07[3]==true){ TCCR2A &= ~((1 << COM2A1) | (1 << COM2A0));  F07[3]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[3]==true) { TCCR2A &= ~((1 << COM2A1) | (1 << COM2A0)); F07[3] = false; } F10[f]=1; F30(f);   }else{ if(F07[3]==false){ TCCR2A |= (1 << COM2A1); TCCR2A &= ~(1 << COM2A0); F07[3]=true; } OCR2A = (uint8_t)((ff / 100.0) * 255); } } } void jm4a_cmaxi::F37(uint8_t f, float ff) { if(f==9 && F06[9]){ OCR1A = (uint32_t)((float)F19[0] * (ff / 100.0)); return; }else if(f==10 && F06[10]){ OCR1B = (uint32_t)((float)F19[0] * (ff / 100.0)); return; } else if(f==0 && F06[0]){ OCR3B = (uint32_t)((float)F19[1] * (ff / 100.0)); return; }else if(f==1 && F06[1]){ OCR3C = (uint32_t)((float)F19[1] * (ff / 100.0)); return; }else if(f==3 && F06[3]){ OCR3A = (uint32_t)((float)F19[1] * (ff / 100.0)); return; } else if(f==4 && F06[4]){ OCR4A = (uint32_t)((float)F19[2] * (ff / 100.0)); return; }else if(f==5 && F06[5]){ OCR4B = (uint32_t)((float)F19[2] * (ff / 100.0)); return; }else if(f==6 && F06[6]){ OCR4C = (uint32_t)((float)F19[2] * (ff / 100.0)); return; } else { F35(); } } void jm4a_cmaxi::F38(uint8_t f, float ff) { switch (f) { case 0: case 1: case 3: case 4: case 5: case 6: case 9: case 10:{ F37(f,ff); return; } case 2: case 7: case 8: case 11:{ F36(f,ff); return; } default:{ F35(); return; }    }     } void jm4a_cmaxi::F39(char* f, uint8_t ff){ uint8_t s; uint32_t t; uint8_t k = 0; uint8_t r = 7; if(f[6]=='/'){ s = ((f[4]- '0') *10)+f[5]-'0'; switch (s) { case 2: case 7: case 8: case 11: { F91(8); return; }     } }else{ F91(2); return; } for(uint8_t i = 7; i<ff; i++){ if(f[i+1]==':'){ k=i; break; } } char a[(k-r)+2]; for(uint8_t i=0; i<(k-r)+1; i++){ a[i]=f[r+i]; } a[(k-r)+1] = '\0'; t = atof(a); int c = floor(t); int b[1] = { static_cast<int>(c) }; F25(b,1); F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; if(F13[1] == F12[1] && F13[0] == F12[0]){ switch (s) { case 9: case 10: { F42(s,t); return; }   case 0: case 1: case 3:{ F43(s,t); return; } case 4: case 5: case 6:{ F44(s,t); return; } default:{ F91(8); }   } }else{ F91(4); } } void jm4a_cmaxi::F40(uint8_t f,uint8_t ff) { if(f==2){ F06[2]=true; F07[0]=true; F05[2]=true; }else{ F06[11]=true; F07[1]=true; F05[11]=true; } uint8_t a = 0; switch(ff) { case 1: a = (1 << CS02) | (1 << CS00); break; case 2: a = (1 << CS02); break; case 3: a = (1 << CS01) | (1 << CS00); break; case 4: a = (1 << CS01); break; case 5: a = (1 << CS00); break; default: a = (1 << CS01) | (1 << CS00); break; } TCCR0A = 0; TCCR0B = 0; TCNT0  = 0; TCCR0A = (1 << WGM00) | (1 << WGM01); TCCR0B = a; F38(f,0.0); } void jm4a_cmaxi::F41(uint8_t f,uint8_t ff) { if(f==7){ F06[7]=true; F07[2]=true; F05[7]=true; }else{ F06[8]=true; F07[3]=true; F05[8]=true; } uint8_t b = 0; switch(ff) { case 1: b = (1 << CS22) | (1 << CS20); break; case 2: b = (1 << CS22); break; case 3: b = (1 << CS21) | (1 << CS20); break; case 4: b = (1 << CS21); break; case 5: b = (1 << CS20); break; default: b = (1 << CS21) | (1 << CS20); break; } TCCR2A = 0; TCCR2B = 0; TCNT2  = 0; TCCR2A = (1 << WGM20) | (1 << WGM21); TCCR2B = b; F38(f,0.0); } void jm4a_cmaxi::F42(uint8_t f, uint32_t ff) { if(!F06[f]){ F91(7); return; } uint32_t c = 16000000UL / (F20[0] * 2UL);      uint32_t z = 16000000UL / (F20[0] * 65536UL);      if(ff > c || ff < z) { enableMFDPO(f,ff); if(f==9){ OCR1A = ICR1 / 2; }else{ OCR1B = ICR1 / 2; } return; } uint32_t s = (16000000UL / (F20[0] * ff)) - 1; TCNT1 = 0;  ICR1 = s; F19[0] = s;   if(f==9){ OCR1A = ICR1 / 2; }else{ OCR1B = ICR1 / 2; } } void jm4a_cmaxi::F43(uint8_t f, uint32_t ff) { if(!F06[f]){ F91(7); return; } uint32_t d = 16000000UL / (F20[1] * 2UL);      uint32_t b = 16000000UL / (F20[1] * 65536UL);      if(ff > d || ff < b) { enableMFDPO(f,ff); if(f==0){ OCR3B = ICR3 / 2; }else if(f==1){ OCR3C = ICR3 / 2; } else{ OCR3A = ICR3 / 2; } return; } uint32_t p = (16000000UL / (F20[1] * ff)) - 1; TCNT3 = 0;  ICR3 = p; F19[1] = p;   if(f==0){ OCR3B = ICR3 / 2; }else if(f==1){ OCR3C = ICR3 / 2; } else{ OCR3A = ICR3 / 2; } } void jm4a_cmaxi::F44(uint8_t f, uint32_t ff) { if(!F06[f]){ F91(7); return; } uint32_t e = 16000000UL / (F20[2] * 2UL);      uint32_t g = 16000000UL / (F20[2] * 65536UL);      if(ff > e || ff < g) { enableMFDPO(f,ff); if(f==4){ OCR4A = ICR4 / 2; }else if(f==5){ OCR4B = ICR4 / 2; } else{ OCR4C = ICR4 / 2; } return; } uint32_t n = (16000000UL / (F20[2] * ff)) - 1; TCNT4 = 0;  ICR4 = n; F19[2] = n;   if(f==4){ OCR4A = ICR4 / 2; }else if(f==5){ OCR4B = ICR4 / 2; } else{ OCR4C = ICR4 / 2; } } void jm4a_cmaxi::F45(uint8_t f, uint32_t ff) { F06[f]=true; F05[f]=true; uint16_t m[] = {1, 8, 64, 256, 1024}; uint8_t n[] = { (1 << CS10),                      (1 << CS11),                      ((1 << CS11) | (1 << CS10)),      (1 << CS12),                    ((1 << CS12) | (1 << CS10))       }; uint8_t o = 0; uint32_t p = 0; for (uint8_t i = 0; i < 5; i++) { p = (16000000UL / (m[i] * ff)) - 1; if (p <= 65535) { o = i; break; } } if (p > 65535) { p = 65535; } F19[0] = p;  F20[0] = m[o]; TCCR1A = 0; TCCR1B = 0; TCCR1A = (1 << WGM11);  if (F06[9]) TCCR1A |= (1 << COM1A1); if (F06[10]) TCCR1A |= (1 << COM1B1); TCCR1B = (1 << WGM13) | (1 << WGM12) | n[o]; TCNT1 = 0; ICR1 = p; } void jm4a_cmaxi::F46(uint8_t f, uint32_t ff) { F06[f]=true; F05[f]=true; uint16_t q[] = {1, 8, 64, 256, 1024}; uint8_t p[] = { (1 << CS30),                   (1 << CS31),                    ((1 << CS31) | (1 << CS30)),      (1 << CS32),                     ((1 << CS32) | (1 << CS30))      }; uint8_t o = 0; uint32_t n = 0; for (uint8_t i = 0; i < 5; i++) { n = (16000000UL / (q[i] * ff)) - 1; if (n <= 65535) { o = i; break; } } if (n > 65535) { n = 65535; } F19[1] = n;  F20[1] = q[o]; TCCR3A = 0; TCCR3B = 0; TCCR3A = (1 << WGM31); if (F06[3]) TCCR3A |= (1 << COM3A1); if (F06[0]) TCCR3A |= (1 << COM3B1); if (F06[1]) TCCR3A |= (1 << COM3C1); TCCR3B = (1 << WGM33) | (1 << WGM32) | p[o]; TCNT3 = 0; ICR3 = n; } void jm4a_cmaxi::F47(uint8_t f, uint32_t ff) { F06[f]=true; F05[f]=true; uint16_t v[] = {1, 8, 64, 256, 1024}; uint8_t n[] = { (1 << CS40),                    (1 << CS41),                     ((1 << CS41) | (1 << CS40)),     (1 << CS42),                      ((1 << CS42) | (1 << CS40))     }; uint8_t m = 0; uint32_t u = 0; for (uint8_t i = 0; i < 5; i++) { u = (16000000UL / (v[i] * ff)) - 1; if (u <= 65535) { m = i; break; } } if (u > 65535) { u = 65535; } F19[2] = u;   F20[2] = v[m]; TCCR4A = 0; TCCR4B = 0; TCCR4A = (1 << WGM41); if (F06[4]) TCCR4A |= (1 << COM4A1); if (F06[5]) TCCR4A |= (1 << COM4B1); if (F06[6]) TCCR4A |= (1 << COM4C1); TCCR4B = (1 << WGM43) | (1 << WGM42) | n[m]; TCNT4 = 0; ICR4 = u; } void jm4a_cmaxi::enableMFDPO(uint8_t f, uint32_t ff) { switch (f) { case 9: case 10: { F45(f,ff); return; } case 0: case 1: case 3:{ F46(f,ff); return; } case 4: case 5: case 6:{ F47(f,ff); return; } default:{ F91(9); return; } } } void jm4a_cmaxi::enableOMDPO(uint8_t f, uint8_t ff) { switch (f) { case 2: case 11:{ F40(f,ff); return; } case 7: case 8: { F41(f,ff); return; } default:{ F91(10); return; } } } void jm4a_cmaxi::setAnalogInput(uint8_t f, uint8_t ff) { if (f >= 0 && f <= 9) { F04[f] = true; F03[f] = ff; } else { F32("-0xC03 Error: Analog input pin index out of range"); } } void jm4a_cmaxi::setAnalogOutput(uint8_t f) { if (f >= 0 && f <= 11) { F05[f] = true; } else { F32("-0xC04 Error: Analog output pin index out of range"); } } void jm4a_cmaxi::noInputs(bool f) { F16 = f; } void jm4a_cmaxi::noOutputs(bool f) { F17 = f; } void jm4a_cmaxi::setID(char f) { if (isalpha(f)) { F21 = f; } else { F32("-0xC05 Error: id non alphabetic"); } } void jm4a_cmaxi::setConfirmation(bool f) { F18 = f; } void jm4a_cmaxi::F91(uint8_t p) { switch (p) { case 0:{ F32("!JM4Automation: Configuration for Controllino Maxi/Arduino Mega/ATMEGA2560"); return; } case 1:{ F32("-0xA00 Error: invalid data"); return; } case 2:{ F32("-0xA01 Error: data format error"); return; } case 3:{ F32("-0xA02 Error: incomplete data"); return; } case 4:{ F32("-0xA03 Error: CRC not match"); return; } case 5:{ F32("-0xB01 Error: indefinite function"); return; } case 6:{ F32("-0xB02 Error: output not available for fast pwm"); return; } case 7:{ F32("-0xB03 Error: PWM mode is disabled for this output"); return; } case 8:{ F32("-0xC01 Error: output not available for modifiable frequency"); return; } case 9:{ F32("-0xD01 Error: output without MFD PWM signal available"); return; } case 10:{ F32("-0xD02 Error: output without OMD PWM signal available"); return; } case 20:{F56 f = "<{\"I\":[";for(int i=0; i<10; i++){if(F04[i]==true){f.F57("1,");}else{f.F57("0,");}}f.F57("0,0],");f.F57("\"O\":[");for(int i=0; i<12; i++){if(F05[i]==true){f.F57("1,");}else{f.F57("0,");}}f.F57("0,0,0,0,0,0,0,0,0,0]}");F32(f);return;}}} 